---
alwaysApply: true
---

  You are an expert in Python, FastAPI, and scalable API development.
  
  Key Principles
  - Write concise, technical responses with accurate Python examples.
  - Use functional, declarative programming; avoid classes where possible.
  - Prefer iteration and modularization over code duplication.
  - Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission).
  - Use lowercase with underscores for directories and files (e.g., routers/user_routes.py).
  - Favor named exports for routes and utility functions.
  - Use the Receive an Object, Return an Object (RORO) pattern.
  
  Python/FastAPI
  - Use def for pure functions and async def for asynchronous operations.
  - Use type hints for all function signatures. Prefer Pydantic models over raw dictionaries for input validation.
  - File structure: exported router, sub-routes, utilities, static content, types (models, schemas).
  - Avoid unnecessary curly braces in conditional statements.
  - For single-line statements in conditionals, omit curly braces.
  - Use concise, one-line syntax for simple conditional statements (e.g., if condition: do_something()).
  
  Error Handling and Validation
  - Prioritize error handling and edge cases:
    - Handle errors and edge cases at the beginning of functions.
    - Use early returns for error conditions to avoid deeply nested if statements.
    - Place the happy path last in the function for improved readability.
    - Avoid unnecessary else statements; use the if-return pattern instead.
    - Use guard clauses to handle preconditions and invalid states early.
    - Implement proper error logging and user-friendly error messages.
    - Use custom error types or error factories for consistent error handling.
  
  Dependencies
  - FastAPI
  - Pydantic v2
  - Async database libraries like asyncpg or aiomysql
  - SQLAlchemy 2.0 (if using ORM features)
  
  FastAPI-Specific Guidelines
  - Use functional components (plain functions) and Pydantic models for input validation and response schemas.
  - Use declarative route definitions with clear return type annotations.
  - Use def for synchronous operations and async def for asynchronous ones.
  - Minimize @app.on_event("startup") and @app.on_event("shutdown"); prefer lifespan context managers for managing startup and shutdown events.
  - Use middleware for logging, error monitoring, and performance optimization.
  - Optimize for performance using async functions for I/O-bound tasks, caching strategies, and lazy loading.
  - Use HTTPException for expected errors and model them as specific HTTP responses.
  - Use middleware for handling unexpected errors, logging, and error monitoring.
  - Use Pydantic's BaseModel for consistent input/output validation and response schemas.
  
  Performance Optimization
  - Minimize blocking I/O operations; use asynchronous operations for all database calls and external API requests.
  - Implement caching for static and frequently accessed data using tools like Redis or in-memory stores.
  - Optimize data serialization and deserialization with Pydantic.
  - Use lazy loading techniques for large datasets and substantial API responses.
  
  Testing Best Practices (pytest)
  - Maintain 100% test coverage for all business logic, routes, and utility functions.
  - Use pytest as the primary testing framework with pytest-asyncio for async tests.
  - Structure tests to mirror the application structure: tests/unit/, tests/integration/, tests/e2e/.
  - Use descriptive test names that explain the scenario being tested (e.g., test_create_user_with_valid_data_succeeds).
  - Follow the Arrange-Act-Assert (AAA) pattern in all test functions.
  - Use fixtures for common test data, database connections, and application setup.
  - Mock external dependencies (databases, APIs, file systems) in unit tests.
  - Use dependency overrides in FastAPI tests to inject test doubles.
  
  Test Dependencies
  - pytest
  - pytest-asyncio (for async test support)
  - pytest-cov (for coverage reporting)
  - httpx (for testing FastAPI applications)
  - factory-boy or faker (for generating test data)
  - pytest-mock (for mocking)
  - pytest-env (for environment variables in tests)
  
  Test Structure and Organization
  - Place test files in a tests/ directory at the same level as the application code.
  - Name test files with test_ prefix and mirror the module structure (e.g., test_user_routes.py for user_routes.py).
  - Group related tests using classes or descriptive function names.
  - Use conftest.py for shared fixtures and test configuration.
  - Separate unit tests from integration tests using markers or directory structure.
  
  Unit Testing Guidelines
  - Test individual functions and methods in isolation.
  - Mock all external dependencies (databases, APIs, file I/O).
  - Test both happy path and edge cases for each function.
  - Use parametrized tests for testing multiple scenarios with the same logic.
  - Test error conditions and exception handling.
  - Ensure tests are deterministic and don't depend on external state.
  
  FastAPI Route Testing
  - Use TestClient from httpx for testing FastAPI applications.
  - Test all HTTP methods (GET, POST, PUT, DELETE) for each endpoint.
  - Verify response status codes, headers, and body content.
  - Test input validation using invalid data scenarios.
  - Test authentication and authorization requirements.
  - Use dependency overrides to inject test doubles for database and external services.
  
  Database Testing
  - Use test databases or in-memory databases for testing.
  - Use database transactions that rollback after each test.
  - Create test data using factories or fixtures.
  - Test database migrations separately from application logic.
  - Use database fixtures for common test scenarios.
  
  Async Testing
  - Use pytest-asyncio for testing async functions and FastAPI routes.
  - Mark async test functions with @pytest.mark.asyncio.
  - Use async fixtures for async setup and teardown.
  - Test both sync and async versions of functions when applicable.
  
  Test Data Management
  - Use factories (factory-boy) for creating test data with realistic values.
  - Create fixtures for common test scenarios and data sets.
  - Use faker for generating realistic test data.
  - Avoid hardcoded test data; use dynamic generation when possible.
  
  Mocking and Stubbing
  - Mock external API calls using unittest.mock or pytest-mock.
  - Use dependency injection to make code testable.
  - Mock time-dependent operations for deterministic tests.
  - Use patch decorators or context managers for mocking.
  
  Coverage and Quality
  - Aim for 100% code coverage on business logic and critical paths.
  - Use pytest-cov to generate coverage reports.
  - Exclude boilerplate code and configuration from coverage requirements.
  - Run tests in CI/CD pipeline before deployment.
  - Use pre-commit hooks to run tests before commits.
  
  Test Configuration
  - Use pytest.ini or pyproject.toml for pytest configuration.
  - Set up different test environments (unit, integration, e2e).
  - Configure test databases and external service mocks.
  - Use environment variables for test configuration.
  
  Example Test Structure:
  ```
  tests/
  ├── conftest.py              # Shared fixtures and configuration
  ├── unit/                    # Unit tests
  │   ├── test_models.py
  │   ├── test_services.py
  │   └── test_utils.py
  ├── integration/             # Integration tests
  │   ├── test_database.py
  │   └── test_external_apis.py
  └── api/                     # API route tests
      ├── test_user_routes.py
      └── test_auth_routes.py
  ```
  
  Key Conventions
  1. Rely on FastAPI's dependency injection system for managing state and shared resources.
  2. Prioritize API performance metrics (response time, latency, throughput).
  3. Limit blocking operations in routes:
     - Favor asynchronous and non-blocking flows.
     - Use dedicated async functions for database and external API operations.
     - Structure routes and dependencies clearly to optimize readability and maintainability.
  4. Write comprehensive tests for all business logic and API endpoints.
  5. Use dependency overrides in tests to inject test doubles and mock external services.
  6. Maintain high test coverage and run tests in CI/CD pipeline.
  
  Refer to FastAPI documentation for Data Models, Path Operations, and Middleware for best practices.
  Refer to pytest documentation for testing best practices and advanced features.
    You are an expert in Python, FastAPI, and scalable API development.
